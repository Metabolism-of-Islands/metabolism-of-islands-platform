from django.db import models

# Used for image resizing
from stdimage.models import StdImageField

# To indicate which site a record belongs to
from django.contrib.sites.models import Site
from django.contrib.sites.managers import CurrentSiteManager
from django.urls import reverse
from django.forms import ModelForm
from django.conf import settings
from markdown import markdown
from tinymce import HTMLField
import re
from django.utils.text import slugify

from django.contrib.auth.models import User
from django.contrib.auth import get_user_model
User = get_user_model()

# To sanitize user input
import bleach
from django.utils.safestring import mark_safe

# For the JSON field
from django.contrib.postgres.fields import JSONField

# To get the geometry fields
from django.contrib.gis.db import models

# To be able to set an UUID
import uuid

# To be able to call just the filename in the file field
# Maybe move to def filename @property?
import os

# For youtube url parsing
from urllib.parse import urlparse, parse_qs

from django.utils import timezone
import pytz

def get_date_range(start, end):

    if not start or not end:
        return None

    start_date = start.strftime("%b %d, %Y")
    start_time = start.strftime("%H:%M")
    end_date = end.strftime("%b %d, %Y")
    end_time = end.strftime("%H:%M")

    if start_date == end_date:
        if start_time == "00:00" and end_time == "00:00":
            return start_date
        elif start_time == end_time:
            return start.strftime("%b %d, %Y %H:%M")
        else:
            return start_date + " " + start_time + " - " + end_time
    else:
        if start.strftime("%Y%m") == end.strftime("%Y%m"):
            return start.strftime("%b") + " " + start.strftime("%d") + " - " + end.strftime("%d") + ", " + start.strftime("%Y")
        elif start_time != "00:00" and end_time != "00:00":
            return start.strftime("%b %d, %Y %H:%M") + " " + end.strftime("%b %d, %Y %H:%M")
        elif start.strftime("%Y") == end.strftime("%Y"):
            return start.strftime("%b %d") + " - " + end_date
        else:
            return start_date + " - " + end_date

# By default we really only want to see those records that are both public and not deleted
class PublicActiveRecordManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False, is_public=True)

# This returns those records that are private (a check around ownership needs to take place in the codebase)
# and that are not deleted
class PrivateRecordManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(is_deleted=False)

class Tag(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    parent_tag = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True,
        limit_choices_to={"hidden": False}, related_name="children"
    )
    hidden = models.BooleanField(db_index=True, default=False, help_text="Mark if tag is superseded/not yet approved/deactivated")
    include_in_glossary = models.BooleanField(db_index=True, default=False)
    belongs_to = models.ForeignKey("Record", on_delete=models.CASCADE, null=True, blank=True)
    is_deleted = models.BooleanField(default=False, db_index=True)
    is_public = models.BooleanField(default=True, db_index=True)
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        return self.name

    @property
    def shortcode(self):
        "Returns abbreviation -- text between parenthesis -- if there is any"
        if "(" in self.name:
            s = self.name
            return s[s.find("(")+1:s.find(")")]
        else:
            return self.name

    class Meta:
        ordering = ["name"]

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Record(models.Model):
    name = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    description_html = models.TextField(null=True, blank=True, help_text="Do not edit... auto-generated by the system")
    image = StdImageField(upload_to="records", variations={"thumbnail": (480, 480), "large": (1280, 1024)}, blank=True, null=True)
    tags = models.ManyToManyField(Tag, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)

    spaces = models.ManyToManyField("ReferenceSpace", blank=True)
    sectors = models.ManyToManyField("Sector", blank=True)
    subscribers = models.ManyToManyField("People", blank=True)

    # We use soft deleted
    is_deleted = models.BooleanField(default=False, db_index=True)

    # Only public records are shown; non-public records are used for instance to manage records 
    # belonging to logged-in users only
    is_public = models.BooleanField(default=True, db_index=True)

    # These relationships are managed through separate tables, but they allow for prefetching to make 
    # the queries run much more efficiently
    child_of = models.ManyToManyField("self", through="RecordRelationship", through_fields=("record_child", "record_parent"), symmetrical=False, related_name="parent_of_child")
    parent_to = models.ManyToManyField("self", through="RecordRelationship", through_fields=("record_parent", "record_child"), symmetrical=False, related_name="child_of_parent")

    # We are going to delete this post-launch
    old_id = models.IntegerField(null=True, blank=True, db_index=True, help_text="Only used for the migration between old and new structure")

    meta_data = JSONField(null=True, blank=True)

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        # We got to fix this!
        if hasattr(self, "libraryitem"):
            return reverse("library:item", args=[self.id])
        else:
            return None

    def get_methodologies(self):
        self.tags.filter(parent_tag__id=318)

    def get_markdown_description(self):
        return markdown(self.description) if self.description else None

    def authors(self):
        return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)

    def author(self):
        try:
            return People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=4)[0]
        except:
            return None

    def get_description(self):
        # The description_html field is already sanitized, according to the settings (see the save() function below)
        # So when we retrieve the html description we can trust this is safe, and will mark it as such
        # We avoid using |safe in templates -- to centralize the effort to sanitize input
        return mark_safe(self.description_html)

    def save(self, *args, **kwargs):
        if not self.description:
            self.description_html = None
        elif self.meta_data and "format" in self.meta_data:
            if self.meta_data["format"] == "markdown_html":
                # Here it wouldn't hurt to apply bleach and take out unnecessary tags
                self.description_html = markdown(self.description)
            elif self.meta_data["format"] == "html":
                # Here it wouldn't hurt to apply bleach and take out unnecessary tags
                self.description_html = self.description
            else:
                self.description_html = markdown(bleach.clean(self.description))
        else:
            self.description_html = markdown(bleach.clean(self.description))
        super().save(*args, **kwargs)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Document(Record):
    file = models.FileField(null=True, blank=True, upload_to="files")

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def getFileName(self):
      filename = str(self.file).split("/")[1]
      return filename

class ProjectType(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=50, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        return self.name

class Project(Record):
    type = models.ForeignKey(ProjectType, on_delete=models.CASCADE, null=True, blank=True)
    contributor_page = HTMLField(null=True, blank=True)
    support_page = HTMLField(null=True, blank=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    STATUS = (
        ("planned", "Planned"),
        ("ongoing", "Ongoing"),
        ("finished", "Finished"),
        ("cancelled", "Cancelled"),
    )
    status = models.CharField(max_length=20, choices=STATUS, default="ongoing")
    has_subsite = models.BooleanField(default=False)
    slug = models.SlugField(max_length=50, unique=True, blank=True, null=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    screenshot = StdImageField(upload_to="project_screenshots", variations={"thumbnail": (350, 350), "medium": (510, 510), "large": (1280, 1024)}, blank=True, null=True, help_text="1280x1024 is best - do not include browser tabs/menus")
    summary_sentence = models.CharField(max_length=255, null=True, blank=True, help_text="Describe the project in a single sentence")

    def get_absolute_url(self):
        return reverse("core:project", args=[self.slug])

    def get_website(self):
        if self.url:
            return self.url
        elif self.has_subsite:
            return "/" + self.slug + "/"
        else:
            return reverse("core:project", args=[self.slug])

    def get_content(self):
        return markdown(self.description) if self.type == "markdown" else self.description

    def get_image(self):
        if self.image:
            return self.image
        elif self.design.logo:
            return self.design.logo
        else:
            return None

    class Meta:
        ordering = ["name"]
    
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class PublicProject(Record):
    full_name = models.CharField(max_length=255, null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    url = models.URLField(max_length=255, null=True, blank=True)
    site = models.ForeignKey(Site, on_delete=models.CASCADE)
    target_finish_date = models.CharField(max_length=255, null=True, blank=True)
    start_date = models.DateField(blank=True, null=True)
    end_date = models.DateField(blank=True, null=True)
    STATUS = (
        ("planned", "Planned"),
        ("ongoing", "Ongoing"),
        ("finished", "Finished"),
        ("cancelled", "Cancelled"),
    )
    status = models.CharField(max_length=20, choices=STATUS, default="ongoing")
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)

    def get_absolute_url(self):
        return reverse("community:project", args=[self.id])

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class News(Record):
    date = models.DateField()
    objects = models.Manager()
    slug = models.SlugField(max_length=255)
    projects = models.ManyToManyField(Project)
    include_in_timeline = models.BooleanField(default=False)

    def get_absolute_url(self):
        return reverse("community:news", args=[self.slug])

    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    class Meta:
        verbose_name_plural = "news"
        ordering = ["-date", "-id"]

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Blog(Record):
    date = models.DateField()
    site = models.ForeignKey(Site, on_delete=models.CASCADE)
    objects = models.Manager()
    on_site = CurrentSiteManager()
    slug = models.SlugField(max_length=255)
    class Meta:
        ordering = ["-date", "-id"]
    def get_absolute_url(self):
        return reverse("blog", args=[self.id])
    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Organization(Record):
    url = models.CharField(max_length=255, null=True, blank=True)
    twitter = models.CharField(max_length=255, null=True, blank=True)
    linkedin = models.CharField(max_length=255, null=True, blank=True)
    researchgate = models.CharField(max_length=255, null=True, blank=True)
    email = models.EmailField(null=True, blank=True)
    slug = models.SlugField(max_length=255)
    ORG_TYPE = (
        ("academic", "Research Institution"),
        ("universities", "Universities"),
        ("city_government", "City Government"),
        ("regional_government", "Regional Government"),
        ("national_government", "National Government"),
        ("statistical_agency", "Statistical Agency"),
        ("private_sector", "Private Sector"),
        ("publisher", "Publishers"),
        ("journal", "Journal"),
        ("society", "Academic Society"),
        ("ngo", "NGO"),
        ("funding_program", "Funding Programme"),
        ("other", "Other"),
    )
    type = models.CharField(max_length=20, choices=ORG_TYPE)

    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    def get_absolute_url(self):
        return reverse("library:journal", args=[self.slug])

    def publications(self):
        # To get all the publications we'll get the LibraryItems that are a child
        # record that are linked to this organization (e.g. journal or publishing house) as a parent
        return LibraryItem.objects.select_related("type").filter(child_list__record_parent=self, child_list__relationship__id=2)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    class Meta:
        ordering = ["name"]

# This defines the relationships that may exist between users and records, or between records
# For instance authors, admins, employee, funder
class Relationship(models.Model):
    name = models.CharField(max_length=255)
    label = models.CharField(max_length=255)
    slug = models.SlugField(max_length=20, db_index=True, unique=True, blank=True, null=True, help_text="Should only be set for permissions, and should only be modified by the programming team")
    description = models.TextField(null=True, blank=True)
    is_permission = models.BooleanField(default=False, help_text="Mark if this relationship is about giving people permissions in the system")
    def __str__(self):
        return self.label

# This defines a particular relationship between two records.
# For instance: Record 100 (company AA) has the relationship "Funder" of Record 104 (Project BB)
# It will always be in the form of RECORD_PARENT is RELATIONSHIP of RECORD_CHILD
# Wiley is the publisher of the JIE. Wiley = record_parent; JIE = record_child
# Fulano is the author of Paper A. Fulano = record_parent; Paper A = record_child 
class RecordRelationship(models.Model):
    record_parent = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="parent_list")
    relationship = models.ForeignKey(Relationship, on_delete=models.CASCADE)
    record_child = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="child_list")

    def __str__(self):
        return str(self.record_parent) + ' ' + str(self.relationship.label) + ' ' + str(self.record_child)

    class Meta:
        verbose_name_plural = "relationship manager"
        verbose_name = "relationship manager"
        unique_together = ["record_parent", "relationship", "record_child"]

class SocialMedia(models.Model):
    record = models.ForeignKey(Record, on_delete=models.CASCADE)
    PLATFORM = [
        ("instagram", "Instagram"),
        ("facebook", "Facebook"),
        ("twitter", "Twitter"),
        ("linkedin", "LinkedIn"),
    ]
    platform = models.CharField(max_length=20, blank=True, null=True, choices=PLATFORM)
    date = models.DateTimeField(null=True, blank=True)
    published = models.BooleanField(default=False)
    blurb = models.TextField(null=True, blank=True)
    response = models.TextField(null=True, blank=True)

class Event(Record):
    EVENT_TYPE = [
        ("conference", "Conference"),
        ("hackathon", "Hackathon"),
        ("workshop", "Workshop"),
        ("seminar", "Seminar"),
        ("summerschool", "Summer School"),
        ("other", "Other"),
        ("training_outreach", "Training and Outreach"),
    ]
    type = models.CharField(max_length=20, blank=True, null=True, choices=EVENT_TYPE)
    url = models.URLField(max_length=255, null=True, blank=True)
    location = models.CharField(max_length=255, null=True, blank=True)
    start_date = models.DateTimeField(null=True, blank=True)
    end_date = models.DateTimeField(null=True, blank=True)
    slug = models.SlugField(max_length=255)
    projects = models.ManyToManyField(Project)

    class Meta:
        ordering = ["-start_date", "-id"]

    def get_absolute_url(self):
        return reverse("community:event", args=[self.id])

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)

    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    def get_status(self):
        try:
            today = timezone.now()
            if self.end_date < today:
                return "finished"
            elif self.start_date <= today and self.end_date >= today:
                return "active"
            else:
                return "upcoming"
        except:
            return "upcoming"

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class People(Record):
    firstname = models.CharField(max_length=255, null=True, blank=True)
    lastname = models.CharField(max_length=255, null=True, blank=True)
    affiliation = models.CharField(max_length=255,null=True, blank=True)
    email = models.EmailField(max_length=255, null=True, blank=True)
    email_public = models.BooleanField(default=False)
    website = models.CharField(max_length=255, null=True, blank=True)
    twitter = models.CharField(max_length=255, null=True, blank=True)
    google_scholar = models.CharField(max_length=255, null=True, blank=True)
    orcid = models.CharField(max_length=255, null=True, blank=True)
    researchgate = models.CharField(max_length=255, null=True, blank=True)
    linkedin = models.CharField(max_length=255, null=True, blank=True)
    research_interests = models.TextField(null=True, blank=True)
    PEOPLE_STATUS = (
        ("active", "Active"),
        ("retired", "Retired"),
        ("deceased", "Deceased"),
        ("inactive", "Inactive"),
        ("pending", "Pending Review"),
    )
    status = models.CharField(max_length=8, choices=PEOPLE_STATUS, default="active")
    user = models.OneToOneField(User, null=True, blank=True, on_delete=models.CASCADE)
    def __str__(self):
        return self.name
    def get_absolute_url(self):
        return reverse("community:person", args=[self.id])
    class Meta:
        verbose_name_plural = "people"
        ordering = ["name"]

    def save(self, *args, **kwargs):
        if self.email:
            self.email=self.email.lower()
        super(People, self).save(*args, **kwargs)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

# We use this to keep a version history of records (which is done for some, not all)
# We save the record name/title and the description, which allows us to go 
# back in time when needed / see a revision history
# It also allows for people to draft a NEW version and review this first before going live
class RecordHistory(models.Model):

    class Status(models.IntegerChoices):
        HISTORIC = 1, "Historic version"
        DRAFT = 2, "New draft version (unapproved)"
        REJECTED = 3, "Rejected version"

    status = models.IntegerField(choices=Status.choices, db_index=True)
    name = models.CharField(max_length=255)
    description = HTMLField(null=True, blank=True)
    date_created = models.DateTimeField(auto_now_add=True)
    record = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="history")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="record_history")

    class Meta:
        ordering = ["-id"]

class Webpage(Record):
    TYPE = [
        ("html", "HTML"),
        ("markdown", "Markdown"),
        ("markdown_html", "Markdown and HTML"),
    ]
    type = models.CharField(max_length=13, choices=TYPE, default="markdown")
    slug = models.CharField(db_index=True, max_length=100)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True, related_name="webpages")

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def get_absolute_url(self):
        return self.slug

    def get_content(self):
        if self.type == "markdown":
            return bleach.clean(markdown(self.description))
        elif self.type == "html":
            return self.description
        elif self.type == "markdown_html":
            return markdown(self.description)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=["part_of_project", "slug"], name="project_slug")
        ]
        ordering = ["name"]

class WebpageDesign(models.Model):
    webpage = models.OneToOneField(Record, on_delete=models.CASCADE, primary_key=True)
    HEADER = [
        ("inherit", "No custom header - use the project header"),
        ("full", "Full header with title and subtitle"),
        ("small", "Small header; menu only"),
        ("image", "Image underneath menu"),
    ]
    header = models.CharField(max_length=7, choices=HEADER, default="full")
    header_title = models.CharField(max_length=100, null=True, blank=True)
    header_subtitle = models.CharField(max_length=255, null=True, blank=True)
    header_image = StdImageField(upload_to="header_image", variations={"thumbnail": (480, 480), "large": (1280, 1024), "huge": (2560, 1440)}, blank=True, null=True)
    custom_css = models.TextField(null=True, blank=True)
    def __str__(self):
        return self.webpage.name

class ProjectDesign(models.Model):
    project = models.OneToOneField(Project, on_delete=models.CASCADE, primary_key=True, related_name="design")
    HEADER = [
        ("full", "Full header with title and subtitle"),
        ("small", "Small header; menu only"),
        ("image", "Image underneath menu"),
    ]
    header = models.CharField(max_length=6, choices=HEADER, default="full")
    HEADER_COLOR = [
        ("dark", "Dark background, light text"),
        ("light", "Light background, dark text"),
    ]
    header_color = models.CharField(max_length=6, choices=HEADER_COLOR, default="dark")
    logo = models.FileField(null=True, blank=True, upload_to="logos")
    custom_css = models.TextField(null=True, blank=True)
    back_link = models.BooleanField(default=True)
    def __str__(self):
        return self.project.name

class ForumTopic(Record):
    last_update = models.ForeignKey("Message", on_delete=models.SET_NULL, null=True, blank=True)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    parent = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="forum_topics")
    is_starred = models.NullBooleanField(default=False)

    def posters(self):
        return People.objects.filter(message_list__parent=self).distinct()

    def get_absolute_url(self):
        return reverse("community:forum", args=[self.id])

    class Meta:
        ordering = ["-is_starred", "-last_update__date_created"]

class Message(Record):
    attachments = models.ManyToManyField(Document, blank=True)
    parent = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="messages")
    posted_by = models.ForeignKey(People, on_delete=models.CASCADE, null=True, blank=True, related_name="message_list")

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        # If this is a forum or work-related message (most of them are) then we need to record
        # in the parent what the latest mesage is (this is for sorting, filtering etc)
        try:
            if hasattr(self.parent, "forumtopic"):
                parent = self.parent.forumtopic
            elif hasattr(self.parent, "work"):
                parent = self.parent.work
            if parent:
                check_last_update = Message.objects.filter(parent=self.parent).order_by("-date_created")
                if check_last_update:
                    parent.last_update = check_last_update[0]
                    parent.save()
        except Exception as e:
            pass

    def getReply(self):
        return Message.objects.filter(parent=self)

    def getLastActivity(self):
        return Message.objects.filter(parent=self).last()

    def getForumMessageFiles(self):
        return self.attachments.all()

    def getContent(self):
        return markdown(self.description)

    def get_absolute_url(self):
        try:
            if hasattr(self.parent, "forumtopic"):
                return reverse("core:forum", args=[self.parent.id])
            elif hasattr(self.parent, "work"):
                return reverse("core:work_item", args=[self.parent.id])
            else:
                return None
        except:
            return None

    class Meta:
        ordering = ["date_created"]

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class License(models.Model):
    name = models.CharField(max_length=255)
    url = models.CharField(max_length=255, null=True, blank=True)
    
    def __str__(self):
        return self.name

    class Meta:
        ordering = ["name"]

class LibraryItemType(models.Model):
    name = models.CharField(max_length=255)
    icon = models.CharField(max_length=255, null=True, blank=True)
    GROUP = (
        ("academic", "Academic"),
        ("theses", "Theses"),
        ("reports", "Reports"),
        ("multimedia", "Multimedia"),
    )
    group = models.CharField(max_length=20, choices=GROUP, null=True, blank=True)

    def __str__(self):
        return self.name
    class Meta:
        ordering = ["name"]

class LibraryItem(Record):
    LANGUAGES = (
        ("EN", "English"),
        ("ES", "Spanish"),
        ("CH", "Chinese"),
        ("FR", "French"),
        ("GE", "German"),
        ("NL", "Dutch"),
        ("PT", "Portuguese"),
        ("OT", "Other"),
    )
    language = models.CharField(max_length=2, choices=LANGUAGES, default="EN")
    title_original_language = models.CharField(max_length=255, blank=True, null=True)
    author_list = models.TextField(null=True, blank=True)
    author_citation = models.TextField(null=True, blank=True)
    bibtex_citation = models.TextField(null=True, blank=True)
    type = models.ForeignKey(LibraryItemType, on_delete=models.CASCADE)
    is_part_of = models.ForeignKey("self", on_delete=models.SET_NULL, null=True, blank=True)
    year = models.PositiveSmallIntegerField()
    abstract_original_language = models.TextField(null=True, blank=True)
    date_added = models.DateTimeField(null=True, blank=True, auto_now_add=True)
    file = models.FileField(null=True, blank=True, upload_to="library")
    url = models.CharField(max_length=500, null=True, blank=True)
    file_url = models.URLField(null=True, blank=True)
    open_access = models.NullBooleanField(null=True, blank=True)
    doi = models.CharField(max_length=255, null=True, blank=True)
    isbn = models.CharField(max_length=255, null=True, blank=True)
    comments = models.TextField(null=True, blank=True)
    license = models.ForeignKey(License, on_delete=models.CASCADE, null=True, blank=True)
    STATUS = (
        ("pending", "Pending"),
        ("active", "Active"),
        ("deleted", "Deleted"),
    )
    # We will delete this after we inserted appropriate work tickets
    status = models.CharField(max_length=8, choices=STATUS, db_index=True, null=True, blank=True, help_text="Old field, do not use")
    #processes = models.ManyToManyField("staf.Process", blank=True, limit_choices_to={"slug__isnull": False})
    #materials = models.ManyToManyField("staf.Material", blank=True)

    def __str__(self):
        return self.name

    class Meta:
        ordering = ["-year", "name"]

    def get_absolute_url(self):
        if self.type_id == 31:
            # Videos are opened in the multimedia library
            return reverse("multimedia:video", args=[self.id])
        elif self.type_id == 33:
            # Data viz are opened in the multimedia library
            return reverse("multimedia:dataviz", args=[self.id])
        elif self.type_id == 24:
            # Podcasts are opened in the multimedia library
            return reverse("multimedia:podcast", args=[self.id])
        else:
            return reverse("library:item", args=[self.id])

    def get_edit_link(self):
        if self.type_id == 31:
            # Videos are opened in the multimedia library
            return "/admin/core/video/" + str(self.id) + "/change/"
        else:
            return "/admin/core/libraryitem/" + str(self.id) + "/change/"

    def publisher(self):
        list = Organization.objects.filter(parent_list__record_child=self, parent_list__relationship__id=2)
        return list[0] if list else None

    def producer(self):
        list = Organization.objects.filter(parent_list__record_child=self, parent_list__relationship__id=3)
        return list[0] if list else None

    def uploader(self):
        list = People.objects.filter(parent_list__record_child=self, parent_list__relationship__id=11)
        return list[0] if list else None

    # The 'author_list' part will be highly varied... some contain Firstname Lastname, Firstname Lastname 
    # others contain Lastname, Firstname and Lastname, Firstname
    # others contain Firstname Lastname; Firstname Lastname; etc.
    # This script tries to get the author_list ready for in-text citation (up to two authors; adding et al 
    # if there are more). 
    def get_author_citation(self):
        if self.author_citation:
            return self.author_citation
        elif self.author_list:
            author_array = []
            author_list = self.author_list
            if " and " in author_list:
                authors = author_list.split(" and ")
                for each in authors:
                    if "," in each:
                        lastname = each.split(",", 1)[0]
                    else:
                        lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            elif ";" in author_list:
                authors = author_list.split(";")
                for each in authors:
                    if "," in each:
                        lastname = each.split(",", 1)[0]
                    else:
                        lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            elif "," in author_list:
                authors = author_list.split(",")
                for each in authors:
                    lastname = each.rpartition(" ")[2]
                    author_array.append(lastname)
            else:
                lastname = author_list.rpartition(" ")[2]
                author_array.append(lastname)
            if len(author_array) == 1:
                return author_array[0]
            elif len(author_array) == 2:
                return author_array[0] + " and " + author_array[1]
            elif len(author_array) > 2:
                return author_array[0] + " <em>et al.</em>"
            else:
                return ""
        else:
            return ""

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Video(LibraryItem):
    embed_code = models.CharField(max_length=20, null=True, blank=True)
    date = models.DateField(blank=True, null=True)
    VIDEO_SITES = [
        ("youtube", "Youtube"),
        ("vimeo", "Vimeo"),
        ("other", "Other"),
    ]
    video_site = models.CharField(max_length=14, choices=VIDEO_SITES)
    def get_absolute_url(self):
        return reverse("multimedia:video", args=[self.id])

    def get_embed_code(self):
        url = self.url
        if not url:
            # This is for ascus only, we should fix / remove later
            url = self.file_url
        if url:
            # Thank you https://stackoverflow.com/questions/4356538/how-can-i-extract-video-id-from-youtubes-link-in-python
            # Examples:
            # - http://youtu.be/SA2iWivDJiE
            # - http://www.youtube.com/watch?v=_oPAwA_Udwc&feature=feedu
            # - http://www.youtube.com/embed/SA2iWivDJiE
            # - http://www.youtube.com/v/SA2iWivDJiE?version=3&amp;hl=en_US
            query = urlparse(url)
            if query.hostname == "youtu.be": return query.path[1:]
            if query.hostname in ("www.youtube.com", "youtube.com"):
                if query.path == "/watch": return parse_qs(query.query)["v"][0]
                if query.path[:7] == "/embed/": return query.path.split("/")[2]
                if query.path[:3] == "/v/": return query.path.split("/")[2]
                return None

    def embed(self):
        if self.video_site == "youtube":
            return f'<iframe class="video-embed youtube-video" src="https://www.youtube.com/embed/{self.embed_code}?rel=0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>'
        elif self.video_site == "vimeo":
            return f'<iframe class="video-embed vimeo-video" title="vimeo-player" src="https://player.vimeo.com/video/{self.embed_code}" frameborder="0" allowfullscreen></iframe>'

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class Photo(LibraryItem):
    position = models.PositiveSmallIntegerField(null=True, blank=True, db_index=True)
    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class ActivatedSpace(models.Model):
    space = models.ForeignKey("ReferenceSpace", on_delete=models.CASCADE)
    site = models.ForeignKey(Site, on_delete=models.CASCADE)
    slug = models.CharField(max_length=255, db_index=True)

    def __str__(self):
        return self.space.name

    def get_absolute_url(self):
        return reverse("data:dashboard", args=[self.slug])

    def save(self, *args, **kwargs):
        self.slug = slugify(self.space.name)
        super().save(*args, **kwargs)

    class Meta:
        unique_together = ["slug", "site"]

class LibraryDataset(LibraryItem):
    data_formats = models.ManyToManyField(Tag, blank=True, related_name="library_datasets", limit_choices_to={"parent_tag_id": 786})
    data_year_start = models.IntegerField(null=True, blank=True)
    data_year_end = models.IntegerField(null=True, blank=True)
    data_interval = models.CharField(max_length=50, null=True, blank=True)
    update_frequency = models.CharField(max_length=50, null=True, blank=True)
    has_api = models.BooleanField(default=True, db_index=True)
    size = models.IntegerField(null=True, blank=True, help_text="Size in MB")

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class LibraryDataPortal(LibraryItem):

    class Software(models.IntegerChoices):
        CKAN = 1, "CKAN"
        DKAN = 2, "DKAN"
        JUNAR = 3, "Junar"
        ODS = 4, "OpenDataSoft"
        SIXCMS = 5, "sixcms"
        SOCRATA = 6, "Socrata"
        TERRA = 7, "terraCatalogue"
        CUSTOM = 8, "Custom / inhouse implementation"
        OTHER = 9, "Other platform"
        ARCGIS = 10, "ArcGIS Open Data"

    software = models.IntegerField(choices=Software.choices, null=True, blank=True)
    has_api = models.BooleanField(default=True, db_index=True)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()


#MOOC's
#class MOOC(models.Model):
#    name = models.CharField(max_length=255)
#    description = models.TextField(null=True, blank=True)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.name
#
#class MOOCQuestion(models.Model):
#    question = models.CharField(max_length=255)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.question
#
#class MOOCModule(models.Model):
#    mooc = models.ForeignKey(MOOC, on_delete=models.CASCADE, related_name="modules")
#    name = models.CharField(max_length=255)
#    instructions = models.TextField(null=True, blank=True)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.name
#
#class MOOCModuleQuestion(models.Model):
#    module = models.ForeignKey(MOOCModule, on_delete=models.CASCADE, related_name="questions")
#    question = models.ForeignKey(MOOCQuestion, on_delete=models.CASCADE)
#    position = models.PositiveSmallIntegerField(db_index=True, null=True, blank=True)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.module.name + " - " + self.question.question
#
#    class Meta:
#        ordering = ["position"]
#
#class MOOCVideo(models.Model):
#    video = models.ForeignKey(Video, on_delete=models.CASCADE)
#    module = models.ForeignKey(MOOCModule, on_delete=models.CASCADE)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.module.name + " - " + self.video.video_site + " - " + self.video.url
#
#class MOOCAnswer(models.Model):
#    question = models.ForeignKey(MOOCQuestion, on_delete=models.CASCADE)
#    answer = models.CharField(max_length=255)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.answer
#
#class MOOCProgress(models.Model):
#    video = models.ForeignKey(MOOCVideo, on_delete=models.CASCADE)
#    module = models.ForeignKey(MOOCModule, on_delete=models.CASCADE)
#    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.module.name
#
#class MOOCQuizAnswers(models.Model):
#    mooc = models.ForeignKey(MOOC, on_delete=models.CASCADE)
#    question = models.ForeignKey(MOOCQuestion, on_delete=models.CASCADE)
#    answer = models.ForeignKey(MOOCAnswer, on_delete=models.CASCADE)
#    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
#    date_created = models.DateTimeField(auto_now_add=True)
#
#    def __str__(self):
#        return self.mooc.name

class WorkActivity(models.Model):

    class WorkType(models.IntegerChoices):
        CREATE = 1, "Creating"
        UPLOAD = 2, "Uploading"
        REVIEW = 3, "Reviewing"
        CURATE = 4, "Curating"
        SHARE = 5, "Sharing"
        PARTICIPATE = 6, "Participating"
        LEARN = 7, "Learning"
        ADMIN = 8, "Administering"
        PROGRAM = 9, "Programming"
        DESIGN = 10, "Designing"
        COMMS = 11, "Communicating"

    type = models.IntegerField(choices=WorkType.choices, db_index=True)
    name = models.CharField(max_length=255)
    instructions = models.TextField(null=True, blank=True)
    default_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    points = models.PositiveSmallIntegerField(null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Is there a specific link a user could go to in order to work on this task? If so, put it here")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name_plural = "work activities"
        ordering = ["name"]

class Work(Record):

    class WorkStatus(models.IntegerChoices):
        OPEN = 1, "Open"
        COMPLETED = 2, "Completed"
        DISCARDED = 3, "Discarded"
        ONHOLD = 4, "On Hold"
        PROGRESS = 5, "In Progress"

    class WorkPriority(models.IntegerChoices):
        LOW = 1, "Low"
        MEDIUM = 2, "Medium"
        HIGH = 3, "High"

    status = models.IntegerField(choices=WorkStatus.choices, db_index=True, default=1)
    priority = models.IntegerField(choices=WorkPriority.choices, db_index=True, default=2)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE, null=True, blank=True)
    workactivity = models.ForeignKey(WorkActivity, on_delete=models.CASCADE, null=True, blank=True)
    related_to = models.ForeignKey(Record, on_delete=models.CASCADE, null=True, blank=True, related_name="my_work")
    assigned_to = models.ForeignKey(People, on_delete=models.CASCADE, null=True, blank=True)
    url = models.URLField(null=True, blank=True, help_text="Is there a specific link a user could go to in order to work on this task? If so, put it here")
    last_update = models.ForeignKey(Message, on_delete=models.SET_NULL, null=True, blank=True)

    def __str__(self):
        return self.name if self.name else self.workactivity.name

    class Meta:
        verbose_name_plural = "work items"

class WorkSprint(Record):

    start_date = models.DateTimeField()
    end_date = models.DateTimeField(null=True, blank=True)
    projects = models.ManyToManyField(Project, blank=True)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def get_dates(self):
        return get_date_range(self.start_date, self.end_date)

    def get_status(self):
        try:
            today = timezone.now()
            if self.end_date < today:
                return "finished"
            elif self.start_date <= today and self.end_date >= today:
                return "active"
            else:
                return "upcoming"
        except:
            return "upcoming"

    class Meta:
        ordering = ["-start_date"]

class Badge(models.Model):

    class BadgeType(models.IntegerChoices):
        BRONZE = 1, "Bronze"
        SILVER = 2, "Silver"
        GOLD = 3, "Gold"

    type = models.IntegerField(choices=BadgeType.choices, db_index=True)
    code = models.CharField(max_length=20, null=True, blank=True, db_index=True)
    name = models.CharField(max_length=255)
    description = models.CharField(max_length=255)
    projects = models.ManyToManyField(Project, blank=True)
    worktype = models.ManyToManyField(WorkActivity, blank=True) 
    required_quantity = models.PositiveSmallIntegerField(null=True, blank=True)
   
    def __str__(self):
        return self.name

    class Meta:
        ordering = ["code", "type"]

#
#
#
# STAFDB TABLES
#
#
#

# The geocode scheme defines a particular standard, for instance 3166-1 or the South African postal code system
class GeocodeScheme(Record):
    url = models.URLField(null=True, blank=True)
    coverage = models.ForeignKey("ReferenceSpace", on_delete=models.SET_NULL, null=True, blank=True)
    is_comprehensive = models.BooleanField(default=True, db_index=True)
    icon = models.CharField(max_length=50, null=True, blank=True) # Web field

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def __str__(self):
        return self.name

    def get_absolute_url(self):
        return reverse("staf:geocode", args=[self.id])

    class Meta:
        db_table = "stafdb_geocode_scheme"

# Lists all the different levels within the system. Could be a single level (e.g. Postal Code), but it 
# could also include various levels, e.g.: Country > Province > City
# Depth should start at 0 and go up from there
class Geocode(Record):
    scheme = models.ForeignKey(GeocodeScheme, on_delete=models.CASCADE, related_name="geocodes")
    depth = models.PositiveSmallIntegerField()

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_geocode"
        ordering = ["depth", "pk"]

# The reference space, for instance the country "South Africa", the city "Cape Town", or the postal code 8000
class ReferenceSpace(Record):
    slug = models.CharField(max_length=255, null=True)
    location = models.ForeignKey("ReferenceSpaceLocation", on_delete=models.SET_NULL, null=True, blank=True)
    geocodes = models.ManyToManyField(Geocode, through="ReferenceSpaceGeocode")

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    @property
    def is_city(self):
        #check = self.geocodes.filter(id=123)
        check = self.geocodes.filter(name="Urban").exists()
        return True if check else False

    @property
    def is_island(self):
        #check = self.geocodes.filter(id=123)
        check = self.geocodes.filter(name="Island").exists()
        return True if check else False

    def photo(self):
        from core.models import Photo
        photo = Photo.objects.filter(spaces=self, is_deleted=False).order_by("position")
        if photo:
            return photo[0]

    class Meta:
        db_table = "stafdb_referencespace"

class ReferenceSpaceLocation(models.Model):
    space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE)
    description = models.TextField(null=True, blank=True)
    start = models.DateField(null=True, blank=True, db_index=True)
    end = models.DateField(null=True, blank=True, db_index=True)
    geometry = models.GeometryField()
    is_deleted = models.BooleanField(default=False, db_index=True)

    def __str__(self):
        return "Location for " + self.space.name

    class Meta:
        db_table = "stafdb_referencespace_location"
        ordering = ["-start"]

class ReferenceSpaceGeocode(models.Model):
    geocode = models.ForeignKey(Geocode, on_delete=models.CASCADE)
    space = models.ForeignKey(ReferenceSpace, on_delete=models.CASCADE)
    identifier = models.CharField(max_length=255, db_index=True, null=True, blank=True)

    class Meta:
        db_table = "stafdb_referencespace_geocode"

class ActivityCatalog(Record):
    url = models.URLField(null=True, blank=True)
    original_file = models.FileField(null=True, blank=True, upload_to="activity_catalogs")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_activitycatalog"
        verbose_name_plural = "activity catalogs"

class Activity(Record):
    catalog = models.ForeignKey(ActivityCatalog, on_delete=models.CASCADE)
    code = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    parent = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    is_separator = models.BooleanField()
    def __str__(self):
        if self.code:
            return self.code + " - " + self.name
        else:
            return self.name

    class Meta:
        db_table = "stafdb_activity"
        verbose_name_plural = "activities"

# The Flow Diagram describes a system (e.g. the Water sector) and describes the life-cycle based on 
# the processes that take place within it (e.g. Water collection > Water treatment > Use > Wastewater treatment)
class FlowDiagram(Record):
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def get_absolute_url(self):
        return reverse("staf:flowdiagram", args=[self.id])

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_flowdiagram"

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

class FlowBlocks(models.Model):
    diagram = models.ForeignKey(FlowDiagram, on_delete=models.CASCADE, related_name="blocks")
    origin = models.ForeignKey(Activity, on_delete=models.CASCADE, related_name="blocks_from")
    origin_label = models.CharField(max_length=255, null=True, blank=True)
    destination = models.ForeignKey(Activity, on_delete=models.CASCADE, related_name="blocks_to")
    destination_label = models.CharField(max_length=255, null=True, blank=True)
    description = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.description if self.description else self.origin.name + " → " + self.destination.name

    def get_destination(self):
        return self.destination_label if self.destination_label else self.destination.name

    def get_origin(self):
        return self.origin_label if self.origin_label else self.origin.name

    def get_destination_slug(self):
        return slugify(self.destination_label) if self.destination_label else slugify(self.destination.name)

    def get_origin_slug(self):
        return slugify(self.origin_label) if self.origin_label else slugify(self.origin.name)

    class Meta:
        db_table = "stafdb_flowblocks"

class MaterialCatalog(Record):
    url = models.CharField(max_length=255, null=True, blank=True)

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_materialcatalog"

class MaterialType(models.IntegerChoices):
    MASS = 1, "Mass"
    VOLUME = 2, "Volume"
    COUNT = 3, "Count"
    AREA = 4, "Area"
    ENERGY = 5, "Energy"
    LENGTH = 6, "Length"
    FRACTION = 7, "Fraction"
    OTHER = 99, "Other"

class Material(Record):
    code = models.CharField(max_length=255, null=True, blank=True, db_index=True)
    parent = models.ForeignKey("self", on_delete=models.CASCADE, null=True, blank=True, related_name="children")
    catalog = models.ForeignKey(MaterialCatalog, on_delete=models.CASCADE, blank=True, null=True)
    #is_separator = models.BooleanField()
    measurement_type = models.IntegerField(choices=MaterialType.choices, db_index=True, blank=True, null=True, default=1)
    icon = models.CharField(max_length=50, null=True, blank=True, help_text="Only include the icon name, not fa- classes --- see https://fontawesome.com/icons?d=gallery")

    def __str__(self):
        if self.code:
            return self.code + " - " + self.name
        else:
            return self.name

    class Meta:
        db_table = "stafdb_material"

class Unit(models.Model):
    name = models.CharField(max_length=255)
    symbol = models.CharField(max_length=255)
    description = models.TextField(null=True, blank=True)
    type = models.IntegerField(choices=MaterialType.choices, db_index=True, default=99)
    multiplication_factor = models.FloatField(null=True, blank=True, help_text="By which factor should we multiply this to get a quantity in the default unit for this type of measurement?")

    def __str__(self):
        return self.name

class MaterialDemand(Record):
    material_type = models.ForeignKey(Material, on_delete=models.CASCADE)
    quantity = models.FloatField()
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE)
    start_date = models.DateField()
    end_date = models.DateField()
    owner = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="demand")

    def __str__(self):
        return self.material_type.name

    def type(self):
        return "supply" if self.quantity < 0 else "demand"

    def absolute_quantity(self):
        return self.quantity*-1 if self.quantity < 0 else self.quantity

    class Meta:
        ordering = ["start_date"]

class Sector(Record):
    icon = models.CharField(max_length=255, null=True, blank=True)
    photo = models.ForeignKey(Photo, on_delete=models.SET_NULL, null=True, blank=True)
    slug = models.SlugField(max_length=255)
    activities = models.ManyToManyField(Activity, db_table="stafdb_sector_activities")

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_sector"

    #def spaces(self):
    #    return ReferenceSpaceType.objects.filter(processes__in=self.processes.all())
    #def datasets(self):
    #    return DatasetType.objects.filter(Q(origin_process__in=self.processes.all()) | Q(destination_process__in=self.processes.all()))

class UploadSession(Record):
    uploader = models.ForeignKey(People, on_delete=models.CASCADE)
    uuid = models.UUIDField(default=uuid.uuid4, editable=False)
    part_of_project = models.ForeignKey(Project, on_delete=models.SET_NULL, null=True, blank=True)
    TYPE = (
        ("shapefile", "Shapefile"),
        ("flowdata", "Material flow data"),
        ("stockdata", "Material stock data"),
    )
    type = models.CharField(max_length=20, choices=TYPE)

    def __str__(self):
        return self.name

    class Meta:
        db_table = "stafdb_uploadsession"

def upload_directory(instance, filename):
    # file will be uploaded to MEDIA_ROOT/uuid/<filename>
    directory = "uploads/"
    if instance.session.part_of_project:
        directory += "project-" + str(instance.session.part_of_project.id) + "/"
    directory += instance.session.type + "/" + str(instance.session.uuid) + "/" + filename
    return directory

class UploadFile(models.Model):
    session = models.ForeignKey(UploadSession, on_delete=models.CASCADE, related_name="files")
    file = models.FileField(upload_to=upload_directory, max_length=255)

    def __str__(self):
        return self.file.name

    @property
    def filename(self):
        return os.path.basename(self.file.name)

    @property
    def extension(self):
        filename, file_extension = os.path.splitext(str(self.file.name))
        return file_extension.lower()

    class Meta:
        db_table = "stafdb_uploadfile"

class DataArticle(Record):

    class Category(models.IntegerChoices):
        LOCAL_INDUSTRIES = 1, "Local industries"
        RESOURCE_USE = 2, "Resource use"
        MATERIAL_STOCK = 3, "Material stock"
        WASTE = 4, "Waste"

    class SubCategory(models.IntegerChoices):
        MANUFACTURING = 1, "Manufacturing industries"
        EXTRACTIVE = 2, "Extractive industries"
        OTHER = 3, "Other industries"

    class Completion(models.IntegerChoices):
        STUB = 1, "Stub"
        HALF = 2, "Medium article"
        COMPLETE = 3, "Complete article"

    category = models.IntegerField(choices=Category.choices, db_index=True)
    sub_category = models.IntegerField(choices=SubCategory.choices, db_index=True, null=True, blank=True)
    completion = models.IntegerField(choices=Completion.choices)
    part_of_project = models.ForeignKey(Project, on_delete=models.CASCADE)

    objects_unfiltered = models.Manager()
    objects_include_private = PrivateRecordManager()
    objects = PublicActiveRecordManager()

# Need to remove this (and from stafdb models) when resetting migrations
def shapefile_directory():
    pass

class Chat(models.Model):
    channel = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="chat_channel")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="chat")
    message = models.TextField()
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return "Chat from " + str(self.people)

    def last_messages(self):
        return Chat.objects.order_by("-timestamp").all()[:50]

class Notification(models.Model):
    record = models.ForeignKey(Record, on_delete=models.CASCADE, related_name="notified_people")
    people = models.ForeignKey(People, on_delete=models.CASCADE, related_name="notifications")
    is_read = models.BooleanField(db_index=True, default=False)

    def __str__(self):
        return str(self.people) + " is notified about " + str(self.record)

class EurostatDB(models.Model):
    title = models.CharField(max_length=2000)
    code = models.CharField(max_length=255)
    type = models.CharField(max_length=255)
    last_update = models.CharField(max_length=255, null=True, blank=True)
    data_start = models.CharField(max_length=255, null=True, blank=True)
    data_end = models.CharField(max_length=255, null=True, blank=True)
    is_reviewed = models.BooleanField(db_index=True, default=False)
    is_approved = models.BooleanField(db_index=True, null=True, blank=True)
    is_denied = models.BooleanField(db_index=True, null=True, blank=True)
    has_no_meta_data = models.BooleanField(db_index=True, null=True, blank=True)
    notes = models.TextField(null=True, blank=True)

    def __str__(self):
        return self.title

from django import forms
class EurostatForm(forms.ModelForm):

    def __init__(self, *args, **kwargs):
        super(EurostatForm, self).__init__(*args, **kwargs)
        self.fields["title"].strip = False

    class Meta:
        model = EurostatDB
        fields = "__all__"
